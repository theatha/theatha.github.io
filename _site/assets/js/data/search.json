[
  
  {
    "title": "Setup A Yara Scanner In Aws Lambda",
    "url": "/posts/Setup-a-YARA-Scanner-in-AWS-Lambda/",
    "categories": "",
    "tags": "",
    "date": "2022-10-03 00:00:00 +0800",
    





    
    "snippet": "IntroductionHello everyone! I’ve been searching how AWS Lambda can be used for analyzing things for a while. So I could get a YARA Scanner that could work on the remote server without messing with ...",
    "content": "IntroductionHello everyone! I’ve been searching how AWS Lambda can be used for analyzing things for a while. So I could get a YARA Scanner that could work on the remote server without messing with the server side and it’s environment. I will explain how I setup a simple YARA Scanner in AWS Lambda in this blog. If you want to discuss or ask me something, you can reach me from twitter.What is AWS Lambda?Lambda is a compute service that lets you run code without provisioning or managing servers. Lambda runs your code on a high-availability compute infrastructure and performs all of the administration of the compute resources, including server and operating system maintenance, capacity provisioning and automatic scaling, and logging. With Lambda, you can run code for virtually any type of application or backend service. Check the docs for more information.StructureThe diagram of the structure is given below. TriggerThe AWS Lambda function must have a trigger. So, I used an S3 bucket as a trigger. Thus, the uploaded binary will trigger the lambda function. Also, you can use different AWS services as trigger. Check the docs for more information.LayersIf a library other than standard libraries will be used, it must be added under Layers. I added all packages under the layers section for I used the “YARA” library.Lambda FunctionI preferred Python for the lambda function.Installing YARA Package under Layers SectionThe “YARA” library is not one of the standard libraries. So, all packages belonging to the “Yara” library must be added to the layers section.mkdir -p layer/python/lib/python3.8/site-packages/pip3 install yara-python -t layer/python/lib/python3.8/site-packages/cd layerzip -r yara-lib.zip *A new layer is created by uploading the zip file and added to the lambda function. However, this is not enough for the “YARA” library to work correctly. Here is the screenshot of log. For solution, libcrypto.1.1.so file must be added to lib/ directory under code source. S3 Bucket as a TriggerAfter the S3 bucket is created, it can be added as a trigger. There is the rules directory and a malicious sample for scanning in the S3 bucket. Policies, PermissionsIn order to both download and list files from S3 Bucket, the given Policy file needs to be edited.    {        \"Sid\": \"VisualEditor1\",        \"Effect\": \"Allow\",        \"Action\": [            \"s3:GetObject\",            \"s3:ListBucket\",            \"logs:CreateLogGroup\"        ],         \"Resource\": [            \"arn:aws:s3:::*/*\"          ]    }Lambda FunctionI will explain the yara scanner code step by step. Importing related libraries.import yaraimport boto3Adding it as a client because the S3 bucket will be used.s3_client = boto3.client(\"s3\")The triggered function is the lambda_handler function. For this reason, the desired operations must be written under this function.def lambda_handler(event, context):Getting the names of yara rule files.# continued    bucket_name = \"&lt;bucketname&gt;\"    response = s3_client.list_objects_v2(Bucket=bucket_name)    rule_list = []     for content in response['Contents']:        if content['Key'].startswith('rules'):            rule_list.append(content['Key'])            rule_list.pop(0)    print(\"rules: \" , rule_list)Reading the file uploaded to S3 Bucket.# continued    uploaded_file = event['Records'][0]['s3']['object']['key']    print('Uploaded file: ', uploaded_file)    response = s3_client.get_object(Bucket=bucket_name, Key=uploaded_file)    uploaded_binary = response['Body'].read()Compiling and running the yara rules on the uploaded file and outputting the match results.# continued    match_status = []    for i in rule_list:        response = s3_client.get_object(Bucket=bucket_name, Key=i)        data = response['Body'].read().decode('utf-8')        rule = yara.compile(source=data)        matches = rule.match(data=uploaded_binary)        #print(matches)        if not matches:            match_status.append(f\"{i} did not match {uploaded_file}\")                        else:            match_status.append(f\"{i} matched {uploaded_file}\")    print(match_status)CloudWatchCloudWatch was used for output. The following image shows the output after a file has been uploaded. The ConclusionA simple Yara Scanner was made with AWS Lambda. I like AWS Lambda because it’s pretty simple and anything can be done easily. You can find source codes, lib, and python packages in “this” repo.Thank you for reading my blog post!"
  },
  
  {
    "title": "Configuration Extraction With Yara",
    "url": "/posts/Configuration-Extraction-with-YARA/",
    "categories": "",
    "tags": "",
    "date": "2022-09-25 00:00:00 +0800",
    





    
    "snippet": "IntroductionHello everyone! Until seeing this blog from _n1ghtw0lf, I did not know that we can use YARA rules for configuration extraction. He wrote a YARA rule for dotnet samples using dotnet and ...",
    "content": "IntroductionHello everyone! Until seeing this blog from _n1ghtw0lf, I did not know that we can use YARA rules for configuration extraction. He wrote a YARA rule for dotnet samples using dotnet and a custom module. Then, it is inspired me to do the same thing for other kinds of samples besides samples that are written in dotnet. However, I could not find any module that gets the data at the given offset. Thus, I decided to write my own helper. Also, I will give an example YARA rule that uses this module to extract the Danabot sample’s configuration.The SituationYARA is mostly aimed at helping people to classify the samples. Typically, researchers would use YARA to detect patterns and identify the sample then will progress with the configuration extraction scripts if they found a known malware. If you insist to use YARA to extract some valuable information from the samples, there are some modules that can help. However, they are not much efficent for configuration extraction. For example, let’s write a configuration extractor with YARA for the Danabot samples without modules. Try to understand YARA rule below;import \"console\"rule DanabotV1_Config_Extraction {    meta:        author = \"Taha Y.\"        danabot_samples = \"https://github.com/f0wl/danaConfig\"    strings:        $s1 = {4D0069006E00690049006E00690074003A004500780063006500700074000000}    condition:        $s1 and console.hex(\"[+] OFFSET \", @s1+214)             and console.log(\"[+] C2-#1:\") and console.log(\"octet-1: \",uint8(@s1+214))             and console.log(\"octet-2: \",uint8(@s1+215)) and console.log(\"octet-3: \",uint8(@s1+216)) and console.log(\"octet-4: \",uint8(@s1+217))             and console.log(\"[+] C2-#2:\") and console.log(\"octet-1: \",uint8(@s1+224))             and console.log(\"octet-2: \",uint8(@s1+225)) and console.log(\"octet-3: \",uint8(@s1+226)) and console.log(\"octet-4: \",uint8(@s1+227))             and console.log(\"[+] C2-#3:\") and console.log(\"octet-1: \",uint8(@s1+234))             and console.log(\"octet-2: \",uint8(@s1+235)) and console.log(\"octet-3: \",uint8(@s1+236)) and console.log(\"octet-4: \",uint8(@s1+237))             and console.log(\"[+] C2-#4:\") and console.log(\"octet-1: \",uint8(@s1+244))             and console.log(\"octet-2: \",uint8(@s1+245)) and console.log(\"octet-3: \",uint8(@s1+246)) and console.log(\"octet-4: \",uint8(@s1+247)) }As you can see, the builtin functions could not much help. We are unable to output the data that is at the given offset properly. Also, we are unable to detect and show the strings that are in this sample directly. So, I do not think that anyone will find this method helpful. So, let’s achieve these goals with the help of YARA modules!YARA ModulesModules are the method YARA provides for extending its features. They allow you to define data structures and functions which can be used in your rules to express more complex conditions. Check the docs for more information.Writing a YARA ModuleModules are written in C and built into YARA as part of the compiling process. In order to create your own modules you must be familiar with the C programming language and how to configure and build YARA from source code. Check the docs for more information.YARA modules reside in libyara/modules, it’s recommended to use the module name as the file name for the source file. Then you should include the necessary libraries and defining the module name in the source code.    #include &lt;yara/modules.h&gt;    #include &lt;inttypes.h&gt;            #define MODULE_NAME parseutilsUsed Structures and Functions ExplainedIf you check the source code parseutils.c, you will see some structures and macros in use. I would like to explain what they are used for.    /*    \tYR_SCAN_CONTEXT*: It is used to inspect the file or process memory being scanned.    \tYR_MEMORY_BLOCK*: Represents the memory block.    \tYR_MEMORY_BLOCK_ITERATOR*: Iterator for memory block.    \tYR_OBJECT*: Represents each object declared in the YARA module.        define_function: Define your function with your desired function name and it's code.        print_int_data: It is a function identifier.    */    // parseutils.print_int_data(offset,size)    define_function(print_int_data){        YR_SCAN_CONTEXT* context = yr_scan_context();        YR_MEMORY_BLOCK* block;        YR_MEMORY_BLOCK_ITERATOR* iterator = context-&gt;iterator;        YR_OBJECT* module = yr_module();        /*            ... continues below           ...        */    }This function takes 2 parameters, offset and size. They can be defined like this:I used foreach_memory_block  and fetch_data to get data according to the given offset and size.    // define_function(print_int_data) continues        // foreach_memory_block macro allows iterating over data sliced into blocks.        foreach_memory_block(iterator, block)        {            // fetch_data returns a pointer to the block's data.            // Each data in the block comes to the block_data            // variable and is thrown into the data array.            const uint8_t* block_data = block-&gt;fetch_data(block);            int t = 0;            for (size_t i = offset_0; i&lt;offset_0+size; i++)            {            uint8_t c = *(block_data + i);            data[t] = c;            t++;            }        }        char str[size];        int index = 0;        // convert the data arr to desired char arr         for(int i=0; i&lt; size; i++)          index += sprintf(&amp;str[index], \"%d \", data[i]);                // set desired output with set_string        yr_set_string(str,module,\"str\");        // return the char arr        return_string(str);    }Then, running included “build.sh” script in YARA will be compiled with this newly created module.The ActionLet’s see parseutils in action!Brief Summary of Danabot’s Configuration StructureLet’s write a new YARA rule that actually outputs  helpful information this time.    import \"console\"    import \"parseutils\"    rule danabot_config_extractor {    \tmeta:    \t\tauthor = \"Taha Y.\"    \t\tdanabot_samples = \"https://github.com/f0wl/danaConfig\"    \tstrings:    \t\t$s1 = {4D0069006E00690049006E00690074003A004500780063006500700074000000}    \t\t$s2 = {2E6F6E696F6E} //.onion    \tcondition:    \t\t$s1 and console.hex(\"OFFSET : \",@s1+224) and     \t\t console.log(\"C2-ip1: \",parseutils.print_int_data(@s1+214,4)) and    \t\t console.log(\"C2-ip2: \",parseutils.print_int_data(@s1+224,4)) and    \t\t console.log(\"C2-ip3: \",parseutils.print_int_data(@s1+234,4)) and    \t\t console.log(\"C2-ip4: \",parseutils.print_int_data(@s1+244,4)) and    \t\t console.log(\"TOR: \",parseutils.print_string_data(@s2-56,62))    }The ConclusionAlthough the YARA project is mainly used for detection and identifying malware samples, I managed to achieve another goal, which is extracting valuable information. Deep deep down, far far in, I feel that this effort is redundant yet shows how much YARA is flexible.You can find mentioned resources and one extra yara rule that extracts information from another Danabot variant in “YARA_for_config_extraction” repository. If you want to discuss or ask me something, you can reach me from twitter."
  }
  
]

